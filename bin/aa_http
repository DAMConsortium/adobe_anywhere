#!/usr/bin/env ruby
begin
  require 'cli'
  require 'adobe_anywhere/http'
rescue LoadError
  lib_path = File.expand_path('../../lib', __FILE__)
  unless $:.include?(lib_path)
    $:.unshift(lib_path)
    #warn("Retrying to load AdobeAnywhere after adding #{lib_path} to $LOAD_PATH. The GEM may not be installed correctly.")
    retry
  end
  abort('Failed to load the AdobeAnywhere gem.')
end

options[:anywhere_default_host_address] = AdobeAnywhere::DEFAULT_HOST_ADDRESS
options[:anywhere_default_host_port] = AdobeAnywhere::DEFAULT_PORT
options[:anywhere_default_username] = AdobeAnywhere::DEFAULT_USERNAME
options[:anywhere_default_password] = AdobeAnywhere::DEFAULT_PASSWORD
options[:log_level] = Logger::WARN

op = common_option_parser.new
op.on('--binding BINDING', 'The address to bind the callback server to.', "\tdefault: #{options[:binding]}") { |v| options[:binding] = v }
op.on('--port PORT', 'The port that the callback server should listen on.', "\tdefault: #{options[:local_port]}") { |v| options[:local_port] = v }
op.on('--anywhere-default-host-address ADDRESS', 'The IP or hostname to use to contact the Adobe Anywhere Server when one is not specified in the XML.') { |v| options[:anywhere_default_host_address] = v }
op.on('--anywhere-default-host-port PORT', 'The port to use to contact the Adobe Anywhere Server when one is not specified in the XML.') { |v| options[:anywhere_default_host_port] = v }
op.on('--anywhere-default-username USERNAME', 'The username to login to the Adobe Anywhere Server when one is not specified in the XML.') { |v| options[:anywhere_default_username] = v }
op.on('--anywhere-default-password PASSWORD', 'The password to login to the Adobe Anywhere Server when one is not specified in the XML.') { |v| options[:anywhere_default_password] = v }
add_common_options
op.parse_common

options[:logger] = Logger.new(options[:log_to] || STDERR)
options[:logger].level = options[:log_level]

begin
  app = AdobeAnywhere::HTTP
  app.init(options)
  app.logger.debug { 'Initialized Anywhere API HTTP.' }
  app.run!
rescue ArgumentError => e
  abort(e.message)
end
