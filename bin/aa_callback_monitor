#!/usr/bin/env ruby
require 'optparse'
require 'pp'

begin
  require 'adobe_anywhere/callback_monitor'
rescue LoadError
  lib_path = File.expand_path('../../lib', __FILE__)
  unless $:.include?(lib_path)
    $:.unshift(lib_path)
    #warn("Retrying to load AdobeAnywhere after adding #{lib_path} to $LOAD_PATH. The GEM may not be installed correctly.")
    retry
  end
  abort("Failed to load the AdobeAnywhere gem. #{$!}")
end

#### CONFIGURATION START

default_successful_job_task = {
  :executable => { :value => %q("echo \'#{JSON.generate({ 'job' => job, 'production' => production, 'assets' => assets, 'asset_media_information' => asset_media_information})}\'   >> /tmp/callback_task_execute"), :eval => true },
  #:arguments => { :eval => true, :value => %q([ "#{request.request_method}", '>', '/tmp/callback_task_execute' ]) },
}
default_failed_job_task = {
  :executable => { :value => %q("echo #{job['jcr:jobName']} SUCCESSFUL > /tmp/callback_task_execute"), :eval => true },

}
default_job_tasks = {
  'SUCCESSFUL' => default_successful_job_task,
  'FAILED' => default_failed_job_task,
}

tasks = {
  'com.adobe.ea.jobs.export' => default_job_tasks,
  'com.adobe.ea.jobs.ingest' => default_job_tasks,
  'com.adobe.ea.jobs.productionconversion' => default_job_tasks,
  'com.adobe.ea.jobs.transfer' => default_job_tasks,
}

path_substitutions = { 'eamedia://media' => '/assets' }

### CONFIGURATION END

app = AdobeAnywhere::CallbackMonitor

options = { }
options[:path_to_mig] = '/Library/Scripts/ubiquity/media_processing_tool/bin/mig'
options[:binding] = '0.0.0.0'
options[:log_level] = Logger::DEBUG


options[:host_address] = '10.42.1.109'
#options[:host_address] = '172.24.15.220'
options[:log_to] = STDOUT

op = OptionParser.new

op.on('--adobe-anywhere-host-address HOSTADDRESS', '') { |v| options[:host_addres] = v }
op.on('--adobe-anywhere-port PORT', '') { |v| options[:port] = v }
op.on('--adobe-anywhere-username USERNAME', '') { |v| options[:username] = v }
op.on('--adobe-anywhere-password PASSWORD', '') { |v| options[:password] = v }
op.on('--[no-]mig-path [FILEPATH]', '') { |v| options[:mig_executable_path] = v }
op.on('--binding BINDING', '') { |v| options[:binding] = v }
op.on('--config-file FILEPATH', '') { |v| options[:config_file] = v }
op.on('--log-to FILEPATH', '') { |v| options[:log_to] = v }
op.on('--log-level LOGLEVEL', '') { |v| options[:log_level] = v }
op.on('--[no-]options-file [FILEPATH]' ) { |v| options[:options_file_name] = v }
op.on_tail('-h', '--help', 'Show this message.') { puts op; exit }
op.load
op.parse!(ARGV.dup)

options_file_name = options[:options_file_name]
op.load(options_file_name) if options_file_name

logger = Logger.new(options[:log_to] || STDOUT)
logger.level = options[:log_level]

options[:logger] = logger

aa = AdobeAnywhere::API::Utilities.new(options)
aa.parse_response = true
aa.http.log_request_body = true
aa.http.log_response_body = true
aa.http.log_pretty_print_body = true

aa.login

app.set(:logger, logger)
existing_methods = app.methods
app.set(:tasks, tasks)
app.set(:path_substitutions, path_substitutions)
app.set(:mig_executable_path, options[:path_to_mig])
app.set(:aa, aa)
app.set(:bind, options[:binding])

logger.debug { "Settings #{(app.methods - existing_methods).keep_if { |v| !v.to_s.end_with?('?', '=')}}" }
logger.debug { "Tasks: #{app.tasks}" }

app.run!

