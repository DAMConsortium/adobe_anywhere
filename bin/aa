#!/usr/bin/env ruby
# An executable that gives access to the methods available in the AdobeAnywhere::Utilities class

require 'optparse'
require 'pp'
begin
  require 'adobe_anywhere/api/utilities'
rescue LoadError
  lib_path = File.expand_path('../../lib', __FILE__)
  unless $:.include?(lib_path)
    $:.unshift(lib_path)
    #warn("Retrying to load AdobeAnywhere after adding #{lib_path} to $LOAD_PATH. The GEM may not be installed correctly.")
    retry
  end
  abort('Failed to load the AdobeAnywhere gem.')
end

ENV_VAR_NAME_ADOBE_ANYWHERE_HOST_ADDRESS = 'ADOBE_ANYWHERE_HOST_ADDRESS'
ENV_VAR_NAME_ADOBE_ANYWHERE_PORT         = 'ADOBE_ANYWHERE_PORT'
ENV_VAR_NAME_ADOBE_ANYWHERE_USERNAME     = 'ADOBE_ANYWHERE_USERNAME'
ENV_VAR_NAME_ADOBE_ANYWHERE_PASSWORD     = 'ADOBE_ANYWHERE_PASSWORD'
ENV_VAR_NAME_ADOBE_ANYWHERE_COOKIE       = 'ADOBE_ANYWHERE_COOKIE'

LOGGING_LEVELS = { :debug => Logger::DEBUG, :info => Logger::INFO, :warn => Logger::WARN,
                   :error => Logger::ERROR, :fatal => Logger::FATAL }

options = {
  :host_address => ENV[ENV_VAR_NAME_ADOBE_ANYWHERE_HOST_ADDRESS] || AdobeAnywhere::DEFAULT_HOST_ADDRESS,
  :port => ENV[ENV_VAR_NAME_ADOBE_ANYWHERE_PORT] || AdobeAnywhere::DEFAULT_PORT,
  :username => ENV[ENV_VAR_NAME_ADOBE_ANYWHERE_USERNAME] || AdobeAnywhere::DEFAULT_USERNAME,
  :password => ENV[ENV_VAR_NAME_ADOBE_ANYWHERE_PASSWORD] || AdobeAnywhere::DEFAULT_PASSWORD,
  :cookie_contents => ENV[ENV_VAR_NAME_ADOBE_ANYWHERE_COOKIE],
  :log_to => STDERR,
  :log_level => Logger::WARN,
}

options_file_name = nil

op = OptionParser.new
op.on('--host-address HOSTADDRESS', 'The AdobeAnywhere server address.',
      "\tdefault: #{options[:host_address]}") { |v| options[:host_address] = v }
op.on('--port PORT', 'The port on the AdobeAnywhere server to connect to.',
      "\tdefault: #{options[:port]}") { |v| options[:port] = v }
op.on('--username USERNAME', 'The username to login with. This will be ignored if cookie contents is set and the force login parameter is false.',
      "\tdefault: #{options[:username]}") { |v| options[:username] = v }
op.on('--password PASSWORD', 'The password to login with. This will be ignored if cookie contents is set and the force login parameter is false.',
      "\tdefault: #{options[:password]}") { |v| options[:password] = v }
op.on('--force-login', 'Forces a new cookie even if cookie information is present.') { |v| options[:force_login] = v }
op.on('--method-name METHODNAME', '') { |v| options[:method_name] = v }
op.on('--method-arguments JSON', '') { |v| options[:method_arguments] = v }
op.on('--pretty-print', '') { |v| options[:pretty_print] = v }
op.on('--cookie-contents CONTENTS', 'Sets the cookie contents.') { |v| options[:cookie_contents] = v }
op.on('--cookie-file-name FILENAME',
      'Sets the cookie contents from the contents of a file.') { |v| options[:cookie_file_name] = v }
op.on('--set-cookie-env',
      "Saves cookie contents to an environmental variable named #{ENV_VAR_NAME_ADOBE_ANYWHERE_COOKIE}") do |v|
  options[:set_cookie_env_var] = v
end
op.on('--set-cookie-file FILENAME', 'Saves cookie contents to a file.') { |v| options[:set_cookie_file_name] = v }
op.on('--log-to FILENAME', 'Log file location.', "\tdefault: STDERR") { |v| options[:log_to] = v }
op.on('--log-level LEVEL', LOGGING_LEVELS.keys, "Logging level. Available Options: #{LOGGING_LEVELS.keys.map { |v| v.to_s}}",
      "\tdefault: #{LOGGING_LEVELS.invert[options[:log_level]]}") { |v| options[:log_level] = LOGGING_LEVELS[v] }
op.on('--[no-]options-file [FILENAME]' ) { |v| options[:options_file_name] = v}
op.on_tail('-h', '--help', 'Show this message.') { puts op; exit }
op.load
op.parse!

options_file_name = options[:options_file_name]
op.load(options_file_name) if options_file_name

#puts options; exit
logger = Logger.new(options[:log_to])
logger.level = options[:log_level] if options[:log_level]
options[:logger] = logger

aa = AdobeAnywhere::API::Utilities.new(options)

options[:cookie_contents] = File.read(options[:cookie_file_name]) if options[:cookie_file_name]
aa.http_cookie = cookie_contents = options[:cookie_contents] if options[:cookie_contents]

begin
  cookie_contents = aa.login(options) unless cookie_contents && !options[:force_login]
rescue => e
  abort "Error performing login on #{aa.http.to_s}. #{e.message}"
end

if cookie_contents
  #logger.debug { "Cookie Contents Set: #{cookie_contents}" }
  ENV[ENV_VAR_NAME_ADOBE_ANYWHERE_COOKIE] = cookie_contents if options[:set_cookie_env_var]
  File.write(options[:set_cookie_file_name], cookie_contents) if options[:set_cookie_file_name]
end #

method_name = options[:method_name]
if method_name
  method_name = method_name.to_sym
  logger.debug { "Executing Method: #{method_name}" }
  method_arguments = options[:method_arguments]

  send_arguments = [ method_name ]
  if method_arguments
    method_arguments = JSON.parse(method_arguments) if method_arguments.is_a?(String) and method_arguments.start_with?('{', '[')
    send_arguments << method_arguments
  end

  response = aa.__send__(*send_arguments)
  if options[:pretty_print]
    if response.is_a?(String)
      puts JSON.pretty_unparse(JSON.parse(response))
    else
      pp response
    end
  else
    response = JSON.generate(response) if response.is_a?(Hash) or response.is_a?(Array)
    puts response
  end
  exit
end

